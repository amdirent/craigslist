#!/usr/bin/env ruby

p 'Starting posts qualifier'

require 'bundler'

Bundler.require(:default, :qualifier)

require_relative 'lib/datadog'

Datadog.emit_event("Qualifying unprocessed posts",
                   msg_title: '[Craigslist Scraper] Qualifier started',
                   priority: 'low',
                   tags: %w{ craigslist_scraper qualify_posts }
                  )

Mail.defaults do
  delivery_method :smtp, { address: 'smtp.gmail.com',
                           port: 587,
                           authentication: 'plain',
                           enable_starttls_auto: true,
                           domain:    ENV['MAIL_DOMAIN'],
                           user_name: ENV['MAIL_USER'],
                           password:  ENV['MAIL_PASS']
                         }
end

pg = PG.connect(host:     ENV['DATABASE_HOST'],
                port:     ENV.fetch('DATABASE_PORT', 5432).to_i,
                dbname:   ENV['DATABASE_NAME'],
                user:     ENV['DATABASE_USER'],
                password: ENV['DATABASE_PASS']
               )

keywords = %w{ ruby
               rails
               python
               javascript
               app
               web
               application
               api
               rest
               programmer
               automate
               unix
               linux
               shell
               script
             }

keyword_query = keywords.join(' | ')

bad_words = %w{ join
                hire
                (full\ &\ time)
                equity
                intern
                java
                studio
                chance
                sell
                seek
                windows
                wordpress
                opportunity
                tester
                survey
                tutor
                cheap
                independent
                employee
                download
              }

bad_words_query = bad_words.join(' | ')

better_filtering = pg.exec_params(<<-SQL, [keyword_query, bad_words_query])
                                    SELECT p.id, p.url, p.title, p.body
                                    FROM posts p,
                                         to_tsquery('english', $1) kw_query,
                                         to_tsquery('english', $2) bw_query
                                    WHERE (p.body_ts || p.title_ts) @@ kw_query
                                      AND NOT (p.body_ts || p.title_ts) @@ bw_query
                                      AND NOT processed
                                    ORDER BY ts_rank(title_ts, kw_query, 32) DESC, ts_rank(body_ts, kw_query, 32) DESC
                                  SQL

potential_leads = pg.exec_params(<<-SQL, [keyword_query])
                                   WITH newly_processed AS (UPDATE posts SET processed = true WHERE NOT processed RETURNING *)
                                   SELECT p.id, p.url, p.title, p.body
                                   FROM newly_processed p,
                                        to_tsquery('english', $1) kw_query
                                   WHERE (p.body_ts || p.title_ts) @@ kw_query
                                   ORDER BY ts_rank(title_ts, kw_query, 32) DESC, ts_rank(body_ts, kw_query, 32) DESC
                                 SQL

formatted_data = potential_leads.map do |post|
  post_body = post['body'].to_s.sub(/^QR Code.*\n/, '').strip

  <<-HTML
    <p>
      <a href="#{post['url']}">#{post['title']}</a>
      <br />
      #{post_body.gsub(/\s+/, ' ').slice(0, 255)}#{post_body.length > 255 ? '...' : ''}
    </p>
  HTML
end

require 'csv'

csv_data = CSV.generate do |csv|
  csv << ['id', 'url', 'title', 'is_relevant', 'notes']
  potential_leads.each do |post|
    csv << [post['id'], post['url'], post['title'], nil, nil]
  end
end


improved_csv = CSV.generate do |csv|
  csv << ['id', 'url', 'title', 'is_relevant', 'notes']
  better_filtering.each do |post|
    csv << [post['id'], post['url'], post['title'], nil, nil]
  end
end

today = Date.today

Mail.deliver do
  to 'anna@amdirent.com'
  cc 'chall@amdirent.com, crankin@amdirent.com'
  from 'help@amdirent.com'
  subject "Craigslist Lead Digest for #{today.strftime('%a, %-d %b %Y')}"

  html_part do
    content_type 'text/html; charset=UTF-8'
    body <<-HTML
           <h2>Daily Lead Digest</h2>
           <table>
             <tr>
               <th>Keywords used:</th>
               <td>#{keywords.join(', ')}</td>
             </tr>
           </table>
           <p>
             #{formatted_data.count} potential leads;
             Ordered by search rank, highest first.
           </p>
           <p style="max-width: 800px">
             #{formatted_data.join("\n")}
           </p>
         HTML
  end

  add_file filename: "digest.#{today.iso8601}.csv",
           mime_type: 'text/csv',
           content: csv_data

  add_file filename: "improved-filter.#{today.iso8601}.csv",
           mime_type: 'text/csv',
           content: improved_csv
end

p 'Mail sent'

at_exit do
  if $!
    # Looks like an error occurred...

    Datadog.emit_event($!.message,
                       msg_title: '[Craigslist Scraper] An error occurred during qualification',
                       alert_type: 'error',
                       tags: %w{ craigslist_scraper qualify_posts }
                      )
  else
    Datadog.emit_event("Posts processed and qualified",
                       msg_title: '[Craigslist Scraper] Qualifier finished',
                       alert_type: 'success',
                       tags: %w{ craigslist_scraper qualify_posts }
                      )
  end
end
